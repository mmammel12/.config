#!/bin/bash

HASH="%C(always,yellow)%h%C(always,reset)"
RELATIVE_TIME="%C(always,green)%ar%C(always,reset)"
AUTHOR="%C(always,bold blue)%an%C(always,reset)"
REFS="%C(always,red)%d%C(always,reset)"
SUBJECT="%s"

FORMAT="$HASH $RELATIVE_TIME{$AUTHOR{$REFS $SUBJECT"

pretty_git_log() {
  git log --graph --pretty="tformat:$FORMAT" $* |
  column -t -s '{' |
  less -XRS --quit-if-one-screen
}

remove_untracked_files() {
  git ls-files --other --exclude-standard | xargs rm -rf
}

prune_branches() {
  git fetch -p
  for branch in $(git for-each-ref --format '%(refname) %(upstream:track)' refs/heads | awk '$2 == "[gone]" {sub("refs/heads/", "", $1); print $1}');
      do git branch -D $branch;
  done
}

commit_and_autosquash() {
    target=$(git log --format=%h --reverse origin/main..main | head -n 1)

    if [ -z "$target" ]; then
        echo "No commits found after origin/main."
        return 1
    fi

    git add .
    git commit --fixup=$target
    git fetch origin main

    # Perform an automatic interactive rebase with autosquash
    GIT_SEQUENCE_EDITOR="sed -i '' -e '/fixup! $target/s/^pick/fixup/'" git rebase -i --autosquash origin/main
}
